# 문제해결기법 2주차 보고서

## Author
20160385 오진영 (sheogorath0213@kaist.ac.kr; github.com/EEngblo)

--------------------------
## Overview

2018년 가을학기 CS202: 문제해결기법 수업의 2-3주차 문제들에 대한 풀이와 그 보고서이다.
	
---------------------

## 문제 2 [apple]

### **접근 전략**

직관적으로 생각했을 때, 가장 쉽게 생각할 수 있는 알고리즘은 n개의 사과들에 대해서 각각 그 사과들로부터 m개씩 앞으로의 사과들의 당도를 조사하여 그 최솟값을 돌려주는 것으로, **O(nm)** 의 시간복잡도를 갖게 된다. 하지만, 이렇게 쉬운 문제를 냈을 리가 없고, 수업에서 다양한 자료구조들을 배웠기 때문에 이것을 이용하여 풀이를 찾고자 시도했다.

우선, 이 문제에 대한 해법은 적어도 모든 사과들에 대해서 한 번은 조사를 해야하기 때문에 적어도 **O(n)** 의 시간복잡도를 갖게 된다. 하지만, 이것은 각각의 사과를 조사할 때 다음 m개의 사과들의 당도를 상수 시간 안에 구할 수 있어야 하기 때문에 불가능하다.

따라서, 최적의 알고리즘의 시간복잡도는 **O(n log m)** 혹은 **O(n log n)** 이 될 것이라는 직관에 기반하여 문제를 풀고자 했고, 로그 시간 내에 최저값을 찾기 위해서는 minHeap이나 binary search tree 구조가 필요할 것이라는 직관에 이르렀다.

minHeap의 경우 최솟값을 바로 찾을 수는 있으나, 원하는 노드를 삭제하는 것이 오래 걸리고 번거롭기 때문에, 지난 수업 시간에 소개되었던 1번 문제의 풀이에 기반하여 map을 이용한 binary search tree를 활용한 알고리즘을 생각했고, 문제를 해결할 수 있었다.

### **알고리즘**

> `m == 1`

이 경우에는 사과를 한 개만 주므로 그냥 입력받은 당도를 즉시 출력하면 된다.

> `m == n`

전체 사과의 개수만큼 주는 것이므로 전체의 최소값을 구한 후 그것을 n번 출력하면 된다.

> 일반 케이스

내가 이 문제를 풀기 위해 사용한 자료구조는 아래와 같다.

```c++
// key: 당도, value: 관심 대상 queue에 있는 사과 중 그 당도의 사과의 수
map<int, int> apples;
map<int, int>::iterator minSweet; // 위의 map BST의 최소값을 가리킬 포인터

queue<int> que; // 관심의 대상이 되는 m개의 사과의 당도에 대한 queue
int* moreApples; // 원형 큐를 구현하기 위해 할당할 동적 배열
```

사과를 원형으로 배열하기 때문에, 원형 자료구조가 필요하다. 간단하게 이를 흉내내기 위하여, m의 크기를 갖는 배열에 처음 m개의 사과의 당도를 집어넣어 그 사과를 n개의 사과를 처리한 후 이어서 더 차리하도록 했다. 이 배열이 `moreApples`이고, 이 작업과 동시에 m개를 먼저 `que`와 `apples` Binary search tree에 넣어 두었다.

이후, m+1번째 사과부터 n+m번째(실제로는 m번째) 사과까지 아래의 작업을 반복한다.

1. `apples.begin()` 부터 시작해서 그 값이 1 이상인 (큐에 하나 이상 들어가 있는) 가장 작은 당도를 찾는다. 이 과정에서 값이 0인 노드는 삭제한다.
2. 그 당도를 출력한다!
3. `que.front()`의 당도에 해당하는 `apples` 맵의 value를 감소시킨다. (`apples[que.front()]--`)
4. 큐에서 사과 하나를 빼고, 새로운 사과의 당도를 큐와 맵에 push한다.

### **복잡도 분석**

위의 알고리즘에서, 큐에 push, pop하는 것, 그리고 `map.begin()`은 상수 시간 안에 이루어지므로, map에 노드를 삭제, 추가, 업데이트하는 것이 가장 많은 시간을 소비한다. 각각은 **O(log n)**의 시간 복잡도를 갖고, 이 작업이 **n** 번 일어나므로 시간복잡도는

**O(n log n)**

이다.

---------------------

## 문제 3 [shade]

### **접근 전략**


### **알고리즘**


### **복잡도 분석**